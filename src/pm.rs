use std::{
    collections::{HashMap, HashSet},
    fs,
    io::{Read, Write},
    process::Command,
};

use crate::network::{TopicManifest, TopicManifests};
use crate::parser::list_installed;
use crate::pk::{create_transaction, find_stable_version_of, get_updated_packages, refresh_cache};
use anyhow::Result;
use dbus::blocking::{Connection, Proxy};
use indexmap::IndexMap;
use lazy_static::lazy_static;
use serde::{Deserialize, Serialize};
use serde_json::{from_slice, to_string};

const SOURCE_HEADER: &[u8] = b"# Generated by AOSC Topic Manager. DO NOT EDIT THIS FILE!\n";
const SOURCE_PATH: &str = "/etc/apt/sources.list.d/atm.list";
const OMAKASE_CONFIG_PATH: &str = "/etc/omakase/config.toml";
const STATE_PATH: &str = "/var/lib/atm/state";
const STATE_DIR: &str = "/var/lib/atm/";
const DPKG_STATE: &str = "/var/lib/dpkg/status";
const APT_GEN_LIST_STATUS: &str = "/var/lib/apt/gen/status.json";
const DEFAULT_REPO_URL: &str = "https://repo.aosc.io";

#[derive(Deserialize, Debug)]
struct AptGenListStatus {
    mirror: IndexMap<String, String>,
}

#[derive(Deserialize, Debug)]
struct Mirror {
    url: String,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
struct OmakaseConfig {
    #[serde(flatten)]
    other: toml::Value,
    repo: HashMap<String, OmakaseTopic>,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
struct OmakaseTopic {
    source: OmakaseSource,
    tag: Option<String>,
    distribution: String,
    components: Vec<String>,
    keys: Vec<String>,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(untagged)]
enum OmakaseSource {
    Url(String),
    MirrorList(OmakaseSourceMirrorList),
}

#[derive(Serialize, Deserialize, Debug, Clone)]
struct OmakaseSourceMirrorList {
    mirrorlist: String,
    prefrred: String,
}

pub struct FrontendStatus {
    pub has_apt: bool,
    pub has_oma: bool,
}

pub fn get_mirror_url() -> Result<String> {
    let status_data = fs::read(APT_GEN_LIST_STATUS)?;
    let status_data: AptGenListStatus = serde_json::from_slice(&status_data)?;
    if let Some((_, url)) = status_data.mirror.first() {
        let url = if url.ends_with('/') {
            url.clone()
        } else {
            format!("{}/", url)
        };
        return Ok(url);
    }

    Ok(DEFAULT_REPO_URL.to_string())
}

lazy_static! {
    pub static ref MIRROR_URL: String =
        get_mirror_url().unwrap_or_else(|_| "https://repo.aosc.io/".to_string());
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct PreviousTopic {
    pub name: String,
    pub description: Option<String>,
    #[serde(default)]
    pub date: i64,
    pub packages: Vec<String>,
}

type PreviousTopics = Vec<PreviousTopic>;

/// Returns the packages need to be reinstalled
pub fn close_topics(topics: &[TopicManifest]) -> Result<Vec<String>> {
    let state_file = fs::read(DPKG_STATE)?;
    let installed = list_installed(&state_file)?;
    let mut remove = Vec::new();

    for topic in topics {
        for package in topic.packages.iter() {
            if installed.contains(package) {
                remove.push(package.clone());
            }
        }
    }

    Ok(remove)
}

/// Returns the list of enrolled topics
fn get_previous_topics() -> Result<PreviousTopics> {
    let f = fs::read(STATE_PATH)?;

    Ok(from_slice(&f)?)
}

pub fn get_display_listing(current: TopicManifests) -> TopicManifests {
    let prev = get_previous_topics().unwrap_or_default();
    let mut lookup: HashMap<String, TopicManifest> = HashMap::new();
    let current_len = current.len();

    for topic in current.into_iter() {
        lookup.insert(topic.name.clone(), topic);
    }

    let mut concatenated = Vec::new();
    concatenated.reserve(prev.len() + current_len);
    for topic in prev {
        if let Some(topic) = lookup.get_mut(&topic.name) {
            topic.enabled = true;
            continue;
        }
        concatenated.push(TopicManifest {
            enabled: false,
            closed: true,
            name: topic.name.clone(),
            description: topic.description.clone(),
            date: topic.date,
            arch: HashSet::new(),
            packages: topic.packages.clone(),
        });
    }
    // consume the lookup table and append all the elements to the concatenated list
    for topic in lookup.into_iter() {
        concatenated.push(topic.1);
    }

    concatenated
}

fn save_as_previous_topics(current: &[&TopicManifest]) -> Result<String> {
    let mut previous_topics = Vec::new();
    for topic in current {
        if !topic.enabled {
            continue;
        }
        previous_topics.push(PreviousTopic {
            name: topic.name.clone(),
            description: topic.description.clone(),
            date: topic.date,
            packages: topic.packages.clone(),
        });
    }

    Ok(to_string(&previous_topics)?)
}

fn make_topic_list(topics: &[&TopicManifest]) -> String {
    let mut output = String::new();
    output.reserve(1024);

    for topic in topics {
        output.push_str(&format!(
            "# Topic `{}`\ndeb {} {} main\n",
            topic.name,
            format!("{}{}", MIRROR_URL.to_string(), "debs"),
            topic.name
        ));
    }

    output
}

fn topic_to_omakase(topics: &[&TopicManifest]) -> Result<HashMap<String, OmakaseTopic>> {
    let mut result = HashMap::new();
    for topic in topics {
        result.insert(
            topic.name.to_owned(),
            OmakaseTopic {
                source: OmakaseSource::Url(get_mirror_url()?),
                tag: Some("topic".to_string()),
                distribution: topic.name.to_owned(),
                components: vec!["main".to_string()],
                keys: vec!["aosc.gpg".to_string()],
            },
        );
    }

    Ok(result)
}

fn make_omakase_config(omakase_topics: HashMap<String, OmakaseTopic>) -> Result<String> {
    let mut file = std::fs::File::open(OMAKASE_CONFIG_PATH)?;
    let mut buf = vec![];
    file.read_to_end(&mut buf)?;
    let mut config: OmakaseConfig = toml::from_slice(&buf)?;
    let mut result = HashMap::new();
    for (repo_name, repo) in config.repo {
        if let Some(tag) = &repo.tag {
            if tag == "topic" {
                continue;
            }
        }
        result.insert(repo_name, repo);
    }
    result = result.into_iter().chain(omakase_topics).collect();
    config.repo = result;

    Ok(toml::to_string(&config)?)
}

pub fn get_frontend_status() -> FrontendStatus {
    let mut has_oma = false;
    let mut has_apt = false;
    let which_oma_output = Command::new("which").arg("oma").output();
    let which_apt_output = Command::new("which").arg("apt").output();
    if let Ok(which_oma_output) = which_oma_output {
        if which_oma_output.status.success() {
            has_oma = true;
        }
    }
    if let Ok(which_apt_output) = which_apt_output {
        if which_apt_output.status.success() {
            has_apt = true;
        }
    }

    FrontendStatus { has_apt, has_oma }
}

pub fn write_source_list(topics: &[&TopicManifest]) -> Result<()> {
    let frontend_status = get_frontend_status();
    if frontend_status.has_apt {
        let mut f = fs::File::create(SOURCE_PATH)?;
        f.write_all(SOURCE_HEADER)?;
        f.write_all(make_topic_list(topics).as_bytes())?;

        fs::create_dir_all(STATE_DIR)?;
        let mut f = fs::File::create(STATE_PATH)?;
        f.write_all(save_as_previous_topics(topics)?.as_bytes())?;
    }
    if frontend_status.has_oma {
        write_omakase_config(topics)?;
    }

    Ok(())
}

pub fn write_omakase_config(topics: &[&TopicManifest]) -> Result<()> {
    let omakase_topics = topic_to_omakase(topics)?;
    let new_config_str = make_omakase_config(omakase_topics)?;
    fs::create_dir_all("/etc/omakase")?;
    let mut f = fs::File::create(OMAKASE_CONFIG_PATH)?;
    f.write_all(new_config_str.as_bytes())?;

    Ok(())
}

pub fn switch_topics(
    proxy: &Proxy<&Connection>,
    closed: &[TopicManifest],
) -> Result<(Vec<String>, Vec<String>)> {
    let tx_proxy = create_transaction(&proxy)?;
    refresh_cache(&tx_proxy)?;
    let removed = close_topics(closed)?;
    let removed = removed.iter().map(|x| x.as_str()).collect::<Vec<_>>();
    let tx_proxy = create_transaction(&proxy)?;
    let (not_found, tasks) = find_stable_version_of(&tx_proxy, &removed)?;
    let tx_proxy = create_transaction(&proxy)?;
    let updated = get_updated_packages(&tx_proxy)?;
    let mut updated = updated
        .into_iter()
        .map(|x| x.package_id)
        .collect::<Vec<_>>();
    updated.extend(tasks);

    Ok((not_found, updated))
}
